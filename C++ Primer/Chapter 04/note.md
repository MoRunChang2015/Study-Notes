# 第四章 表达式

### 4.1

+ 当一个对象被用作**右值**的时候，用的是对象的值(内容)，当对象被用作**左值**的时候，用的是对象的身份(在内存中的位置)。

+ 需要右值的地方可以用左值代替，但是不能把右值当成左值(也就是位置)使用。当一个左值被当成右值使用的的时候，实际使用的是它的内容(值)。

+ 如果表达式求值结果是左值，**decltype**作用于该表达式(不是变量)得到一个引用类型。
```c++
    int* p = &a
    decltype(*p) //得到int&
    decltype(&p) //得到int**
```

+ 优先级规定了运算对象的组合方式，但是没有说明运算对象按照什么顺序求值，只有４种运算符明确规定了运算对象的求值顺序(**&& || ?: ,**) `int i = f1() * f2()`，无法确定f1先调用还是f2先调用。

+ 对于那些没有指定执行顺序的运算符来说，如果表达式指向并修改了同一个对象，将会引发错误并产生未定义的行为。
```c++
    int i = 0;
    cout << i  << " " << ++i << endl;
```

+ 拿不准的时候最好用括号来强制让表达式的组合关系符合程序逻辑的顺序

+ 如果改变了某个运算对象的值，在表达式的其他地方不要再使用这个运算对象。(除了类似与`*++iter`)

### 4.2

+ **c++11**新标准规定商一律向０取整(即直接切除小数部分)

+ 新标准: **(-m)/n**和**m/(-n)**都等于**-(m/n)**, **(-m)%n**等于**-(m%n)**, **m%(-n)**等于**m%n**。

### 4.3

+ 进行比较运算时除非比较的对象是布尔类型，否则不要使用布尔字面值**true**和**false**作为运算对象。否则**true**或**false**会强制转换成其他类型再进行比较。

### 4.4

+ **c++11**允许使用花括号括起来的初始值列表作为赋值语句的右侧运算对象。
```c++
    int k;
    k = {3.14}  //错误：窄化转换
    vector<int> v;
    v = {0,1,2,3,4,5,6,7,8,9};
```

+ 如果左侧运算对象是内置类型，那么初始值列表最多只能包含一个值，而且该值即使转换的话其所占空间也**不应该大于**目标类型的空间。对于类类型来说，赋值运算的细节由类本身决定。

### 4.5

+ 除非必须，否则不用递增递减运算符的后置版本。因为使用后置版本会导致多复制一份对象的副本而影响性能。

### 4.6

+ 箭头运算符作用于一个指针类型的运算对象，结果是一个左值。

+ 点运算符分成两种情况:如果成员所属的对象是左值，那么结果是左值；反之，如果成员所属的对象是右值，那么结果是右值。

### 4.7

+ 注意条件运算符(?:)的优先级比较多低，尤其是在与cout连用的时候要注意加括号。
```c++
    cout << ((grade < 60) ? "fail" : "pass"); // 输出pass或者fail
    cout << (grade < 60) ? "fail" : "pass"; // 输出0或１
    cout << grade < 60 ? "fail" : "pass"; // 错误：试图比较cout和0
```

### 4.8

+ 在位运算过程中，关于符号位如何处理没有明确的规定，所以强烈建议仅将位运算符用于处理无符号类型。如果运算对象是"小整形"，则它的值会被提升成较大的整数类型

### 4.9

+ **c++11**允许使用作用域运算符来获取类成员大小，如`sizeof Sales_data::revenue`

+ 对string对象或者vector对象执行sizeof运算只返回该类型固定部分的大小，不会计算对象中的元素占用了多少空间。

### 4.10

+ 逗号运算符的返回值是**右侧**表达式的值。

### 4.11

+ 只要不包含**底层const**，都可以使用static_cast,const_cast只能改变运算对象的顶层const，注意如果对象本身不是一个常量，使用强制类型转换获得写权限是合法的，然而如果对象是一个常量，再使用const_cast执行写操作就会**产生未定义的后果**。

+ 不建议使用**reinterpret_cast<>()**，很可能导致**未定义的后果**。

## 4.12

+ 有一些特殊的操作符(如`sizeof... noexcept() ->* `)在后续的笔记中补充。
