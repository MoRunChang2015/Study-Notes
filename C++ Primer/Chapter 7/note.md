# 第七章 类

### 7.1

+ 定义在类内部的函数是隐式的**inline**函数

+ 构造函数不能被声明为**const**的，当我们创建类的一个const对象时，知道构造函数完成初始化过程，对象才能真正取得其"常量"属性。因此，构造函数再const对象的构造过程中可以向其写值。

+ 类通过一个特殊的构造函数来控制默认初始化过程，这个函数叫**默认构造函数**，由编译器创建的构造函数又被称为**合成默认构造函数**，一般来说按照以下规则初始化成员
1. 如果存在类内的初始值，用它来初始化成员
2. 否则，默认初始化该成员。

+ 只有当类没有声明任何构造函数的时候，编译器才会自动地生成默认构造函数。

+ **c++11**中，如果需要使用编译器创建的**合成默认构造函数**，使用方式如下。其中`=default`既可以和声明一起出现在类的内部，也可以作为定义出现在类的外部，和其他函数一样，出现在内部则默认构造函数是内联的，如果出现再外部则，该成员函数默认情况下不是内联的。
```c++
class A {
    int a = 1;
    A() = default;
}
```

+ 当某个数据成员被构造函数初始值列表忽略时，它将以与合成默认构造函数的相同方式隐式初始化。

+ 跟默认构造函数类似，如果不手动定义拷贝，赋值和析构，编译器将会自动合成对对象的每个成员执行拷贝，赋值和销毁的操作。

### 7.2

+ 使用**struct**和使用**class**定义类的唯一差别是默认访问权限。


### 7.3

+ 类可以自定义某种类型在类中的别名，同样受访问控制符的约束。其次，用来定义类型的的成员必须先定义后使用。

+ 在变量声明的时候加入**mutable**关键字可以让该变量在const对象或者const方法中改变它的值。

+ 一个空的类如下，占一个字节的内存空间。因为c++要求每个实例都有一个唯一的内存地址，空的类的对象也是一个实例所以占1字节。
```c++
class A {
};
```

+ 我们可以只声明一个类而不定义它，如`class Screen;`这种声明被称作**前向声明**，对于类型Screen来说它是一个不完全类型，不完全类型只能定义这种类型的指针或者引用，可以声明以不完全类型作为参数或者返回值的函数，不能创建它的对象。这就是为什么类的成员类型不能是它自己，但是可以是它自身的指针或者引用。

+ 友元可以是类，其他类(之前定义过)的成员函数和普通函数，且友元关系不存在传递性

+ 友元声明的作用是影响访问权限，它本身并非普通意义上的声明，如果需要使用友元必须在声明后使用。

### 7.4

+ 在类中，如果成员使用了外层作用域中的某个名字，而该名字代表一种类型，则类不能在之后重新定义该名字
```c++
typedef double Money;
class Account {
public:
    Money balance();
private:
    typedef double Money // Error!!
};
```

### 7.5

+ 如果成员是**const**、**引用**，或者属于某种未提供默认构造函数的类类型，我们必须通过构造函数初始值列表为这些成员提供初始值。

+ 成员的初始化顺序与它们在类定义中出现的顺序一致。

+ c++11中，新定义了**委托构造函数**，也就是可以使用它所属类的其他构造函数执行它自己的初始化过程。

+ 注意
```c++
Sales_data obj(); // 声明了一个函数而非对象
Sales_data obj;   // 利用默认构造函数定义了一个对象
```

+ 能通过一个实参调用的构造函数定义了一条从构造函数的参数类型向类类型隐式转换的规则，但这种转换只允许一步类类型转换。如果想抑制这种转换，可以将构造函数声明为**explicit**，该关键字只对一个参数的构造函数有效。即使加了**explicit**关键字，依然可以通过显式地进行强制转换。

+ 当一个类满足：所有成员都是public的，没有定义任何构造函数，没有类内初始值，没有基类，没有virtual函数，这个类是聚合类。可以用一个花括号括起来的初始值列表根据数据成员的声明顺序来进行初始化。
```c++
struct Data {
    int val;
    string s;
};

Data val1 = {0, "test"};
```

+ 字面值常量类对构造函数和数据成员有特别的要求。


### 7.6

+ 不能在类的内部初始化静态成员，必须在类的外部定义和初始化每个静态成员，除非静态成员是静态成员是字面值常量类型的constexpr，可以在类内提供const整数类型的类内初始值，且这个应用场景仅限于编译器可以替换它的值的情况，如果不能替换则必须有一条定义语句，定义语句不能带有初始值。

+ 静态数据成员可以是不完全类型，特别的，静态数据成员的类型可以就是它所属的类类型。

+ 可以使用静态成员作为默认实参。
