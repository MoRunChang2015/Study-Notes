# 第七章 类

### 7.1

+ 定义在类内部的函数是隐式的**inline**函数

+ 构造函数不能被声明为**const**的，当我们创建类的一个const对象时，知道构造函数完成初始化过程，对象才能真正取得其"常量"属性。因此，构造函数再const对象的构造过程中可以向其写值。

+ 类通过一个特殊的构造函数来控制默认初始化过程，这个函数叫**默认构造函数**，由编译器创建的构造函数又被称为**合成默认构造函数**，一般来说按照以下规则初始化成员
1. 如果存在类内的初始值，用它来初始化成员
2. 否则，默认初始化该成员。

+ 只有当类没有声明任何构造函数的时候，编译器才会自动地生成默认构造函数。

+ **c++11**中，如果需要使用编译器创建的**合成默认构造函数**，使用方式如下。其中`=default`既可以和声明一起出现在类的内部，也可以作为定义出现在类的外部，和其他函数一样，出现在内部则默认构造函数是内联的，如果出现再外部则，该成员函数默认情况下不是内联的。
```c++
class A {
    int a = 1;
    A() = default;
}
```

+ 当某个数据成员被构造函数初始值列表忽略时，它将以与合成默认构造函数的相同方式隐式初始化。

+ 跟默认构造函数类似，如果不手动定义拷贝，赋值和析构，编译器将会自动合成对对象的每个成员执行拷贝，赋值和销毁的操作。

### 7.2

+ 使用**struct**和使用**class**定义类的唯一差别是默认访问权限。


### 7.3

+ 类可以自定义某种类型在类中的别名，同样受访问控制符的约束。其次，用来定义类型的的成员必须先定义后使用。

+ 在变量声明的时候加入**mutable**关键字可以让该变量在const对象或者const方法中改变它的值。

+ 一个空的类如下，占一个字节的内存空间。因为c++要求每个实例都有一个唯一的内存地址，空的类的对象也是一个实例所以占1字节。
```c++
class A {
};
```

+ 我们可以只声明一个类而不定义它，如`class Screen;`这种声明被称作**前向声明**，对于类型Screen来说它是一个不完全类型，不完全类型只能定义这种类型的指针或者引用，可以声明以不完全类型作为参数或者返回值的函数，不能创建它的对象。这就是为什么类的成员类型不能是它自己，但是可以是它自身的指针或者引用。

+ 友元可以是类，其他类(之前定义过)的成员函数和普通函数，且友元关系不存在传递性

+ 友元声明的作用是影响访问权限，它本身并非普通意义上的声明，如果需要使用友元必须在声明后使用。

### 7.4

+ 在类中，如果成员使用了外层作用域中的某个名字，而该名字代表一种类型，则类不能在之后重新定义该名字
```c++
typedef double Money;
class Account {
public:
    Money balance();
private:
    typedef double Money // Error!!
};
```

### 7.5

+ 如果成员是**const**、**引用**，或者属于某种未提供默认构造函数的类类型，我们必须通过构造函数初始值列表为这些成员提供初始值。

+ 成员的初始化顺序与它们在类定义中出现的顺序一致。

+ c++11中，新定义了**委托构造函数**，也就是可以使用它所属类的其他构造函数执行它自己的初始化过程。
