# 第十五章 面向对象程序设计

### 15.1

+ 面向对象程序设计的核心思想是**数据抽象，继承和动态绑定**。

+ 在c++中，当使用基类的引用(指针)调用一个虚函数时将发送动态绑定，也称为运行时绑定。

### 15.2

+ 基类通常都应该定义一个虚析构函数，即使该函数不执行任何实际操作也是如此。

+ 基类通过再其成员函数的声明语句之前加上关键字virtual使得该函数执行动态绑定。任何构造函数之外的非静态函数都可以是虚函数。

+ 在c++11中，可以显式地防止继承的发生，就是在类名后跟一个`final`
```c++
class NoBerived final {
  ....
}
```

+ 和内置指针一样，智能指针类也支持派生类向基类的类型转换。

+ 一个变量或其他表达式的**静态类型**是在编译时已知的，它是变量声明时的类型或表达式生成的类型。**动态类型**则是变量或表达式表示的内存中对象的类型，直到运行时才可知。

+ 通过基类的指针或引用绑定派生类的时候不一定安全，所以如果基类中含有一个或多个虚函数的时候可以使用**dynamic_cast**请求一个类型转换，该类型转换的安全检查会在运行时执行。

+ 当用一个派生类对象为一个基类对象初始化或赋值的时候，只有该派生类对象中的基类部分会被拷贝，移动或赋值，它的派生类部分将被忽略掉。３．


### 15.3

+ 一旦某个函数被声明为虚函数，则在所有派生类中它都是虚函数，所以派生类覆盖某个虚函数时可以写也可以不写`virtual`关键字。

+ 一个派生类的函数如果覆盖了某个继承而来的虚函数，则它的形参类型必须与被它覆盖的基类函数完全一致，同样，派生类中虚函数的返回类型必须与基类函数匹配，除非返回类型是类本身的指针或引用。例如D由B派生，则基类的虚函数可以返回`B*`而派生类的对应函数可以返回`D*`，只不过这样的返回类型要求从D到B的类型转换是可访问的。

+ **c++11**,在派生类中可以显式地表面该函数是用于覆盖基类中的虚函数，这样编译器会帮忙检查是否有覆盖，可以避免参数列表写错的错误。
```c++
struct B {
    virtual void f1(int) const;
    virtual void f2();
    void f3();
};

struct D1: B {
    void f1(int) const override; //　与基类的f1匹配
    void f2(int) override; //　Error 基类中没有f2(int)的虚函数
    void f3() override; // Error f3不是虚函数
}
```

+ 继上条，可以在基类中显式表明该函数不能被覆盖。
```c++
struct B {
    void f1(int) const final;
};

struct D : B {
    viod f1() const ; // Error
}
```

+ 虚函数可以有默认形参，如果某次函数调用使用了默认实参，则该实参由本次调用的静态类型决定。也就是说，通过基类的引用或指针调用虚函数，就把基类的默认实参传入派生类的对应函数。所以如果虚函数使用默认实参，则基类和派生类中定义的默认实参最好一致。

+ 可以通过域作用符强制要求对虚函数的调用不进行动态绑定，而是强迫执行虚函数的某个版本(称为回避虚函数机制)。该调用在编译时完成解析。
