# 第四章 表达式

### 4.1

+ 当一个对象被用作**右值**的时候，用的是对象的值(内容)，当对象被用作**左值**的时候，用的是对象的身份(在内存中的位置)。

+ 需要右值的地方可以用左值代替，但是不能把右值当成左值(也就是位置)使用。当一个左值被当成右值使用的的时候，实际使用的是它的内容(值)。

+ 如果表达式求值结果是左值，**decltype**作用于该表达式(不是变量)得到一个引用类型。
```c++
    int* p = &a
    decltype(*p) //得到int&
    decltype(&p) //得到int**
```

+ 优先级规定了运算对象的组合方式，但是没有说明运算对象按照什么顺序求值，只有４种运算符明确规定了运算对象的求值顺序(**&& || ?: ,**) `int i = f1() * f2()`，无法确定f1先调用还是f2先调用。

+ 对于那些没有指定执行顺序的运算符来说，如果表达式指向并修改了同一个对象，将会引发错误并产生未定义的行为。
```c++
    int i = 0;
    cout << i  << " " << ++i << endl;
```

+ 不准的时候最好用括号来强制让表达式的组合关系符合程序逻辑的要去

+ 如果改变了某个运算对象的值，在表达式的其他地方不要再使用这个运算对象。(除了类似与`*++iter`)

### 4.2

+ **c++11**新标准规定商一律向０取整(即直接切除小数部分)

+ 新标准: **(-m)/n**和**m/(-n)**都等于**-(m/n)**, **(-m)%n**等于**-(m%n)**, **m%(-n)**等于**m%n**。

### 4.3

+ 进行比较运算时除非比较的对象是布尔类型，否则不要使用布尔字面值**true**和**false**作为运算对象。否则**true**或**false**会强制转换成其他类型再进行比较。

### 4.4

+ **c++11**允许使用花括号括起来的初始值列表作为赋值语句的右侧运算对象。
```c++
    int k;
    k = {3.14}  //错误：窄化转换
    vector<int> v;
    v = {0,1,2,3,4,5,6,7,8,9};
```

+ 如果左侧运算对象是内置类型，那么初始值列表最多只能包含一个值，而且该值即使转换的话其所占空间也**不应该大于**目标类型的空间。对于类类型来说，赋值运算的细节由类本身决定。

### 4.5

+ 除非必须，否则不用递增递减运算符的后置版本。因为使用后置版本会导致多复制一份对象的副本而影响性能。
