# 第十三章 拷贝控制

### 13.1

+ 赋值运算符通常应该返回一个指向其左侧运算对象的引用。

+ 在析构函数中，首先执行函数体，然后销毁成员。成员按照初始化顺序的逆序销毁。

+ c++语言并不要求定义所有拷贝构造函数，拷贝赋值运算符，析构函数等。有一定的规则可以遵循。**需要析构函数的类也需要拷贝和赋值操作**(分配动态内存)，**需要拷贝操作的类也需要赋值操作(反之亦然)**

+ 只能对具有合成版本的成员函数使用**=default**(即，默认构造函数或拷贝控制成员)，但是可以对任何函数指定`=delete`来阻止一些行为(必须在第一次声明的时候)。

+ 析构函数不能是删除的成员，如果被删除了就不能定义该类型的变量或释放指向该类型动态分配对象的指针。合成拷贝控制成员可能是删除的：如果一个类有数据成员不能默认构造，拷贝，复制或者销毁，则对应的成员函数将被定义为删除的。

+ 本质上，当不可能拷贝，赋值或者销毁类的成员时，类的合成拷贝控制成员就被定义为删除的了。


### 13.2

+ 编写赋值运算符的时候，需要保证
1. 如果一个对象赋值它自身，赋值运算符必须能正常工作
2. 大多数赋值运算符结合了析构函数和拷贝构造函数的工作。


### 13.3

+ 除了定义拷贝控制成员，管理资源的类通常还定义了一个名为swap的函数，那些与重排元素顺序的算法一起使用的类，定义swap非常重要。
```c++
class HasPtr {
    friend void swap(HasPtr&, HasPtr&);
}
```
