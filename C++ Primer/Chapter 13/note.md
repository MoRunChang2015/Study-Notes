# 第十三章 拷贝控制

### 13.1

+ 赋值运算符通常应该返回一个指向其左侧运算对象的引用。

+ 在析构函数中，首先执行函数体，然后销毁成员。成员按照初始化顺序的逆序销毁。

+ c++语言并不要求定义所有拷贝构造函数，拷贝赋值运算符，析构函数等。有一定的规则可以遵循。**需要析构函数的类也需要拷贝和赋值操作**(分配动态内存)，**需要拷贝操作的类也需要赋值操作(反之亦然)**

+ 只能对具有合成版本的成员函数使用**=default**(即，默认构造函数或拷贝控制成员)，但是可以对任何函数指定`=delete`来阻止一些行为(必须在第一次声明的时候)。

+ 析构函数不能是删除的成员，如果被删除了就不能定义该类型的变量或释放指向该类型动态分配对象的指针。合成拷贝控制成员可能是删除的：如果一个类有数据成员不能默认构造，拷贝，复制或者销毁，则对应的成员函数将被定义为删除的。

+ 本质上，当不可能拷贝，赋值或者销毁类的成员时，类的合成拷贝控制成员就被定义为删除的了。


### 13.2

+ 编写赋值运算符的时候，需要保证
1. 如果一个对象赋值它自身，赋值运算符必须能正常工作
2. 大多数赋值运算符结合了析构函数和拷贝构造函数的工作。


### 13.3

+ 除了定义拷贝控制成员，管理资源的类通常还定义了一个名为swap的函数，那些与重排元素顺序的算法一起使用的类，定义swap非常重要。
```c++
class HasPtr {
    friend void swap(HasPtr&, HasPtr&);
}
```

### 13.6

+ 标准库容器，string和shared_ptr类既支持移动也支持拷贝。IO类和unique_ptr类可以移动不可以拷贝。

+ **右值引用**，就是必须绑定到右值的引用，只能绑定到一个将要销毁的对象，因此，可以自由地将一个右值引用移动到另一个对象中。．

+ 变量是左值，因此我们不能将一个右值引用直接绑定到一个变量上，即使这个变量是右值引用类型也不行。可以通过调用一个**move**的库函数来获取绑定到左值上的右值引用(需要引入头文件utility)

+ 使用move的代码应该使用`std::move`而不是`move`。这样做可以避免潜在的名字冲突。

+ `noexcept`用于通知标准库构造函数不抛出任何异常,移动构造函数需要保证移后源是销毁无害的。
```c++
    A::A(A &&a) noexcept: p1(s.p1), p2(s.p2) { s.p1 = s.p2 = nullptr }
```
 
+ 不抛出异常的移动构造函数和移动赋值运算符必须标记为noexcept
 
+ 在移动操作之后，移后源对象必须保持有效的、可析构的状态，但是用户不能对其值进行任何假设。
 
+ 只有当一个类没有定义任何自己版本的拷贝构造函数，且类的每个非static数据成员都可以移动时，编译器才会为它合成移动构造函数或移动赋值运算符。编译器可以移动内置类型的成员，如果一个成员是类类型，且该类有对应的移动操作，编译器也能移动这个成员。
 
+ 如果类定义了一个移动构造函数或一个移动赋值运算符，则该类的合成拷贝构造函数和拷贝赋值运算符会被定义为删除的。
 
+ 移动右值，拷贝左值。但如果没有移动构造函数，右值也被拷贝。
 
+ 新标准库中定义一种移动迭代器适配器`make_move_iterator`，一个移动迭代器通过改变给定迭代器的解引用运算符的行为来适配此迭代器，移动迭代解引用运算符生成一个右值引用。

+ 只有在确信移后源没有用户时才可使用move。

+ 区分移动和拷贝的重载函数通常有一个版本接受一个const T&, 另一个接受 T&&。

+ c++11中，可以指出this的左值/右值属性的定义形式与const成员函数相同，在参数列表后放置一个引用限定符(＆表示只能向左值，&&右值)，引用限定符只能用于（非static）成员函数，且必须同时出现在函数的声明和定义中。
```c++
Foo &operatro=(const Foo&) &;
Foo anotherMem() const &;
```

+ 就像一个成员函数可以根据是否有const来区分其重载版本一样，引用限定符也可以区分重载版本。

+ 如果一个成员函数有引用控制符，则具有相同参数列表的所有版本都必须有引用控制符。
