# 第十章 泛型算法

### 10.1

+ 泛型算法本身不会执行容器的操作，它们只会运行于迭代器之上，执行迭代器的操作。


### 10.2

+ 那些只接受一个单一迭代器来表示第二个序列的算法，都假定第二个序列至少与第一个序列一样长。

+ 向目的位置迭代器写入数据的算法假定目的的位置足够大，能够容纳写入的元素。
```c++
vector<int> vec;
fill_n(vec.begin(), 10, 0); // 未定义行为
```

+ 插入迭代器(insert iterator)是一种向容器中添加元素的迭代器。定义在头文件**iterator**中的**back_inserter**接收一个指向容器的引用，返回一个与该容器绑定的插入迭代器。
```c++
vector<int> vec;
fill_n(back_inserter(vec), 10, 0);
```

+ 标准库算法对迭代器而不是容器进行操作。因此，算法不能(直接)添加或删除元素。


### 10.3

+ 谓词是一个可调用的表达式，其返回结果是一个能用作条件的值。标准库算法所使用的谓词分为两类：一元谓词，二元谓词。接收谓词参数的算法对输入序列中的元素调用谓词，所以，元素类型必须能转换为谓词的参数类型。

+ **lambda**表达式的形式如下,其中可以忽略参数列表和返回类型，但必须永远包含捕获列表和函数体。
```
[capture](parameter list) -> return type { function body }
```

+ **如果lambda的函数体包含任何单一return语句之外的内容，且未指定返回类型，则返回void？？？**

+ 捕获列表只用于局部**非static**变量，lambda可以直接使用局部static变量和它所在函数之外声明的名字。

+ 当定义一个lambda时，编译器生成一个与lambda对应的新的(未命名的)类类型。默认情况下，从lambda生成的类都包含一个对应该lambda所捕获的变量的数据成员，lambda的数据成员在lambda对象创建是初始化。

+ 在lambda表达式中，被捕获的变量的值是在lambda创建是拷贝，而不是调用时拷贝。

+ lambda表达式的引用捕获与返回引用有着相同的问题和限制，如果采用引用的方式捕获一个变量，就必须确保被引用的对象在lambda表达式执行的时候是存在的。

+ 混合使用隐式捕获和显式捕获的时候，捕获列表中的第一个元素必须是`&或者=`。

+　如果希望改变值捕获的变量的值，就必须在参数列表首加上关键字**mutable**。
```c++
int a = 0;
auto f = [a] ()mutable {a++; return a;};
```
